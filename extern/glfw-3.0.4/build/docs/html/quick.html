<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<title>GLFW: Getting started</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
	<div class="glfwheader">
		<a href="http://www.glfw.org/" id="glfwhome">GLFW</a>
		<ul class="glfwnavbar">
			<li><a href="http://www.glfw.org/documentation.html">Documentation</a></li>
			<li><a href="http://www.glfw.org/download.html">Download</a></li>
			<li><a href="http://www.glfw.org/media.html">Media</a></li>
			<li><a href="http://www.glfw.org/community.html">Community</a></li>
		</ul>
	</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Getting started </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#quick_include">Including the GLFW header</a></li>
<li class="level1"><a href="#quick_init_term">Initializing and terminating GLFW</a></li>
<li class="level1"><a href="#quick_capture_error">Setting an error callback</a></li>
<li class="level1"><a href="#quick_create_window">Creating a window and context</a></li>
<li class="level1"><a href="#quick_context_current">Making the OpenGL context current</a></li>
<li class="level1"><a href="#quick_window_close">Checking the window close flag</a></li>
<li class="level1"><a href="#quick_key_input">Receiving input events</a></li>
<li class="level1"><a href="#quick_render">Rendering with OpenGL</a></li>
<li class="level1"><a href="#quick_timer">Reading the timer</a></li>
<li class="level1"><a href="#quick_swap_buffers">Swapping buffers</a></li>
<li class="level1"><a href="#quick_process_events">Processing events</a></li>
<li class="level1"><a href="#quick_example">Putting it together: A small GLFW application</a></li>
</ul>
</div>
<div class="textblock"><p >This guide will show how to write simple OpenGL applications using GLFW 3. It will introduce a few of the most commonly used functions, but there are many others. To see detailed documentation on any GLFW function, just click on its name.</p>
<p >This guide assumes no experience with earlier versions of GLFW. If you have used GLFW 2.x in the past, you should also read the <a class="el" href="moving.html">transition guide</a>.</p>
<h1><a class="anchor" id="quick_include"></a>
Including the GLFW header</h1>
<p >In the files of your program where you use OpenGL or GLFW, you need to include the GLFW 3 header file.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="glfw3_8h.html">GLFW/glfw3.h</a>&gt;</span></div>
<div class="ttc" id="aglfw3_8h_html"><div class="ttname"><a href="glfw3_8h.html">glfw3.h</a></div></div>
</div><!-- fragment --><p >This defines all the constants, types and function prototypes of the GLFW API. It also includes the OpenGL header, and defines all the constants and types necessary for it to work on your platform.</p>
<p >For example, under Windows you are normally required to include <code>windows.h</code> before including <code>GL/gl.h</code>. This would make your source file tied to Windows and pollute your code's namespace with the whole Win32 API.</p>
<p >Instead, the GLFW header takes care of this for you, not by including <code>windows.h</code>, but rather by itself duplicating only the necessary parts of it. It does this only where needed, so if <code>windows.h</code> <em>is</em> included, the GLFW header does not try to redefine those symbols.</p>
<p >In other words:</p>
<ul>
<li>Do <em>not</em> include the OpenGL headers yourself, as GLFW does this for you</li>
<li>Do <em>not</em> include <code>windows.h</code> or other platform-specific headers unless you plan on using those APIs directly</li>
<li>If you <em>do</em> need to include such headers, do it <em>before</em> including the GLFW one and it will detect this</li>
</ul>
<p >Starting with version 3.0, the GLU header <code>glu.h</code> is no longer included by default. If you wish to include it, define <code>GLFW_INCLUDE_GLU</code> before the inclusion of the GLFW header.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define GLFW_INCLUDE_GLU</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="glfw3_8h.html">GLFW/glfw3.h</a>&gt;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="quick_init_term"></a>
Initializing and terminating GLFW</h1>
<p >Before you can use most GLFW functions, the library must be initialized. This is done with <a class="el" href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a>, which returns non-zero if successful, or zero if an error occurred.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a>())</div>
<div class="line">    exit(EXIT_FAILURE);</div>
<div class="ttc" id="agroup__init_html_ga317aac130a235ab08c6db0834907d85e"><div class="ttname"><a href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a></div><div class="ttdeci">int glfwInit(void)</div><div class="ttdoc">Initializes the GLFW library.</div></div>
</div><!-- fragment --><p >When you are done using GLFW, typically at the very end of the program, you need to call <a class="el" href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a>();</div>
<div class="ttc" id="agroup__init_html_gaaae48c0a18607ea4a4ba951d939f0901"><div class="ttname"><a href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a></div><div class="ttdeci">void glfwTerminate(void)</div><div class="ttdoc">Terminates the GLFW library.</div></div>
</div><!-- fragment --><p >This destroys any remaining windows and releases any other resources allocated by GLFW. After this call, you must call <a class="el" href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a> again before using any GLFW functions that require it.</p>
<h1><a class="anchor" id="quick_capture_error"></a>
Setting an error callback</h1>
<p >Most events are reported through callbacks, whether it's a key being pressed, a GLFW window being moved, or an error occurring. Callbacks are simply C functions (or C++ static methods) that are called by GLFW with arguments describing the event.</p>
<p >In case <a class="el" href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a> or any other GLFW function fails, an error is reported to the GLFW error callback. You can receive these reports by setting the error callback. The callback function itself should match the signature of <a class="el" href="group__error.html#gaa684e3f8b44b6a35000119d524d49e6d">GLFWerrorfun</a>. Here is a simple error callback that just prints the error description to <code>stderr</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> error_callback(<span class="keywordtype">int</span> error, <span class="keyword">const</span> <span class="keywordtype">char</span>* description)</div>
<div class="line">{</div>
<div class="line">    fputs(description, stderr);</div>
<div class="line">}</div>
</div><!-- fragment --><p >Setting the callback, so GLFW knows to call it, is done with <a class="el" href="group__error.html#gaa5d796c3cf7c1a7f02f845486333fb5f">glfwSetErrorCallback</a>. This is one of the few GLFW functions that may be called before <a class="el" href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a>, which lets you be notified of errors during initialization, so you should set it before you do anything else with GLFW.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__error.html#gaa5d796c3cf7c1a7f02f845486333fb5f">glfwSetErrorCallback</a>(error_callback);</div>
<div class="ttc" id="agroup__error_html_gaa5d796c3cf7c1a7f02f845486333fb5f"><div class="ttname"><a href="group__error.html#gaa5d796c3cf7c1a7f02f845486333fb5f">glfwSetErrorCallback</a></div><div class="ttdeci">GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun cbfun)</div><div class="ttdoc">Sets the error callback.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="quick_create_window"></a>
Creating a window and context</h1>
<p >The window (and its context) is created with <a class="el" href="group__window.html#ga3555a418df92ad53f917597fe2f64aeb">glfwCreateWindow</a>, which returns a handle to the created window. For example, this creates a 640 by 480 windowed mode window:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window = <a class="code hl_function" href="group__window.html#ga3555a418df92ad53f917597fe2f64aeb">glfwCreateWindow</a>(640, 480, <span class="stringliteral">&quot;My Title&quot;</span>, NULL, NULL);</div>
<div class="ttc" id="agroup__window_html_ga3555a418df92ad53f917597fe2f64aeb"><div class="ttname"><a href="group__window.html#ga3555a418df92ad53f917597fe2f64aeb">glfwCreateWindow</a></div><div class="ttdeci">GLFWwindow * glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share)</div><div class="ttdoc">Creates a window and its associated context.</div></div>
<div class="ttc" id="agroup__window_html_ga3c96d80d363e67d13a41b5d1821f3242"><div class="ttname"><a href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a></div><div class="ttdeci">struct GLFWwindow GLFWwindow</div><div class="ttdoc">Opaque window object.</div><div class="ttdef"><b>Definition:</b> glfw3.h:574</div></div>
</div><!-- fragment --><p >If window creation fails, <code>NULL</code> will be returned, so you need to check whether it did.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!window)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_function" href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a>();</div>
<div class="line">    exit(EXIT_FAILURE);</div>
<div class="line">}</div>
</div><!-- fragment --><p >This handle is then passed to all window related functions, and is provided to you along with input events, so you know which window received the input.</p>
<p >To create a full screen window, you need to specify which monitor the window should use. In most cases, the user's primary monitor is a good choice. You can get this with <a class="el" href="group__monitor.html#gac3adb24947eb709e1874028272e5dfc5">glfwGetPrimaryMonitor</a>. To make the above window full screen, just pass along the monitor handle:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window = <a class="code hl_function" href="group__window.html#ga3555a418df92ad53f917597fe2f64aeb">glfwCreateWindow</a>(640, 480, <span class="stringliteral">&quot;My Title&quot;</span>, <a class="code hl_function" href="group__monitor.html#gac3adb24947eb709e1874028272e5dfc5">glfwGetPrimaryMonitor</a>(), NULL);</div>
<div class="ttc" id="agroup__monitor_html_gac3adb24947eb709e1874028272e5dfc5"><div class="ttname"><a href="group__monitor.html#gac3adb24947eb709e1874028272e5dfc5">glfwGetPrimaryMonitor</a></div><div class="ttdeci">GLFWmonitor * glfwGetPrimaryMonitor(void)</div><div class="ttdoc">Returns the primary monitor.</div></div>
</div><!-- fragment --><p >Full screen windows cover the entire display area of a monitor, have no border or decorations, and change the monitor's resolution to the one most closely matching the requested window size.</p>
<p >When you are done with the window, destroy it with the <a class="el" href="group__window.html#gacdf43e51376051d2c091662e9fe3d7b2">glfwDestroyWindow</a> function.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__window.html#gacdf43e51376051d2c091662e9fe3d7b2">glfwDestroyWindow</a>(window);</div>
<div class="ttc" id="agroup__window_html_gacdf43e51376051d2c091662e9fe3d7b2"><div class="ttname"><a href="group__window.html#gacdf43e51376051d2c091662e9fe3d7b2">glfwDestroyWindow</a></div><div class="ttdeci">void glfwDestroyWindow(GLFWwindow *window)</div><div class="ttdoc">Destroys the specified window and its context.</div></div>
</div><!-- fragment --><p >Once this function is called, no more events will be delivered for that window and its handle becomes invalid.</p>
<h1><a class="anchor" id="quick_context_current"></a>
Making the OpenGL context current</h1>
<p >Before you can use the OpenGL API, it must have a current OpenGL context. You make a window's context current with <a class="el" href="group__context.html#ga1c04dc242268f827290fe40aa1c91157">glfwMakeContextCurrent</a>. It will then remain as the current context until you make another context current or until the window owning it is destroyed.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__context.html#ga1c04dc242268f827290fe40aa1c91157">glfwMakeContextCurrent</a>(window);</div>
<div class="ttc" id="agroup__context_html_ga1c04dc242268f827290fe40aa1c91157"><div class="ttname"><a href="group__context.html#ga1c04dc242268f827290fe40aa1c91157">glfwMakeContextCurrent</a></div><div class="ttdeci">void glfwMakeContextCurrent(GLFWwindow *window)</div><div class="ttdoc">Makes the context of the specified window current for the calling thread.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="quick_window_close"></a>
Checking the window close flag</h1>
<p >Each window has a flag indicating whether the window should be closed. This can be checked with <a class="el" href="group__window.html#ga24e02fbfefbb81fc45320989f8140ab5">glfwWindowShouldClose</a>. <br  />
</p>
<p >When the user attempts to close the window, either by pressing the close widget in the title bar or using a key combination like Alt+F4, this flag is set to 1. Note that <b>the window isn't actually closed</b>, so you are expected to monitor this flag and either destroy the window or give some kind of feedback to the user.</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (!<a class="code hl_function" href="group__window.html#ga24e02fbfefbb81fc45320989f8140ab5">glfwWindowShouldClose</a>(window))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Keep running</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__window_html_ga24e02fbfefbb81fc45320989f8140ab5"><div class="ttname"><a href="group__window.html#ga24e02fbfefbb81fc45320989f8140ab5">glfwWindowShouldClose</a></div><div class="ttdeci">int glfwWindowShouldClose(GLFWwindow *window)</div><div class="ttdoc">Checks the close flag of the specified window.</div></div>
</div><!-- fragment --><p >You can be notified when user is attempting to close the window by setting a close callback with <a class="el" href="group__window.html#gaade9264e79fae52bdb78e2df11ee8d6a">glfwSetWindowCloseCallback</a>. The callback will be called immediately after the close flag has been set.</p>
<p >You can also set it yourself with <a class="el" href="group__window.html#ga49c449dde2a6f87d996f4daaa09d6708">glfwSetWindowShouldClose</a>. This can be useful if you want to interpret other kinds of input as closing the window, like for example pressing the escape key.</p>
<h1><a class="anchor" id="quick_key_input"></a>
Receiving input events</h1>
<p >Each window has a large number of callbacks that can be set to receive all the various kinds of events. To receive key press and release events, a <a class="el" href="group__input.html#ga9c6c9d019ac11d888e45b11b14772659">key callback</a> is set using <a class="el" href="group__input.html#ga7e496507126f35ea72f01b2e6ef6d155">glfwSetKeyCallback</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> key_callback(<a class="code hl_typedef" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> scancode, <span class="keywordtype">int</span> action, <span class="keywordtype">int</span> mods)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (key == <a class="code hl_define" href="group__keys.html#gaac6596c350b635c245113b81c2123b93">GLFW_KEY_ESCAPE</a> &amp;&amp; action == <a class="code hl_define" href="group__input.html#ga2485743d0b59df3791c45951c4195265">GLFW_PRESS</a>)</div>
<div class="line">        <a class="code hl_function" href="group__window.html#ga49c449dde2a6f87d996f4daaa09d6708">glfwSetWindowShouldClose</a>(window, GL_TRUE);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__input_html_ga2485743d0b59df3791c45951c4195265"><div class="ttname"><a href="group__input.html#ga2485743d0b59df3791c45951c4195265">GLFW_PRESS</a></div><div class="ttdeci">#define GLFW_PRESS</div><div class="ttdoc">The key or button was pressed.</div><div class="ttdef"><b>Definition:</b> glfw3.h:242</div></div>
<div class="ttc" id="agroup__keys_html_gaac6596c350b635c245113b81c2123b93"><div class="ttname"><a href="group__keys.html#gaac6596c350b635c245113b81c2123b93">GLFW_KEY_ESCAPE</a></div><div class="ttdeci">#define GLFW_KEY_ESCAPE</div><div class="ttdef"><b>Definition:</b> glfw3.h:326</div></div>
<div class="ttc" id="agroup__window_html_ga49c449dde2a6f87d996f4daaa09d6708"><div class="ttname"><a href="group__window.html#ga49c449dde2a6f87d996f4daaa09d6708">glfwSetWindowShouldClose</a></div><div class="ttdeci">void glfwSetWindowShouldClose(GLFWwindow *window, int value)</div><div class="ttdoc">Sets the close flag of the specified window.</div></div>
</div><!-- fragment --><p >For event callbacks to actually be called when an event occurs, you need to process events as described below.</p>
<h1><a class="anchor" id="quick_render"></a>
Rendering with OpenGL</h1>
<p >Once you have a current OpenGL context, you can use OpenGL normally. In this tutorial, a multi-colored rotating triangle will be rendered. The framebuffer size, needed by this example for <code>glViewport</code> and <code>glOrtho</code>, is retrieved with <a class="el" href="group__window.html#ga0e2637a4161afb283f5300c7f94785c9">glfwGetFramebufferSize</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> width, height;</div>
<div class="line"><a class="code hl_function" href="group__window.html#ga0e2637a4161afb283f5300c7f94785c9">glfwGetFramebufferSize</a>(window, &amp;width, &amp;height);</div>
<div class="line">glViewport(0, 0, width, height);</div>
<div class="ttc" id="agroup__window_html_ga0e2637a4161afb283f5300c7f94785c9"><div class="ttname"><a href="group__window.html#ga0e2637a4161afb283f5300c7f94785c9">glfwGetFramebufferSize</a></div><div class="ttdeci">void glfwGetFramebufferSize(GLFWwindow *window, int *width, int *height)</div><div class="ttdoc">Retrieves the size of the framebuffer of the specified window.</div></div>
</div><!-- fragment --><p >However, you can also set a framebuffer size callback using <a class="el" href="group__window.html#ga3203461a5303bf289f2e05f854b2f7cf">glfwSetFramebufferSizeCallback</a> and call <code>glViewport</code> from there.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> framebuffer_size_callback(<a class="code hl_typedef" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)</div>
<div class="line">{</div>
<div class="line">    glViewport(0, 0, width, height);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="quick_timer"></a>
Reading the timer</h1>
<p >For the triangle to rotate properly, a time source is needed. GLFW provides <a class="el" href="group__time.html#gaa6cf4e7a77158a3b8fd00328b1720a4a">glfwGetTime</a>, which returns the number of seconds since <a class="el" href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a> as a <code>double</code>. The time source used is the most accurate on each platform and generally has micro- or nanosecond resolution.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> time = <a class="code hl_function" href="group__time.html#gaa6cf4e7a77158a3b8fd00328b1720a4a">glfwGetTime</a>();</div>
<div class="ttc" id="agroup__time_html_gaa6cf4e7a77158a3b8fd00328b1720a4a"><div class="ttname"><a href="group__time.html#gaa6cf4e7a77158a3b8fd00328b1720a4a">glfwGetTime</a></div><div class="ttdeci">double glfwGetTime(void)</div><div class="ttdoc">Returns the value of the GLFW timer.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="quick_swap_buffers"></a>
Swapping buffers</h1>
<p >GLFW windows always use double-buffering. That means that you have two rendering buffers; a front buffer and a back buffer. The front buffer is the one being displayed and the back buffer the one you render to.</p>
<p >When the entire frame has been rendered, it is time to swap the back and the front buffers in order to display the rendered frame, and begin rendering a new frame. This is done with <a class="el" href="group__context.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14">glfwSwapBuffers</a>.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__context.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14">glfwSwapBuffers</a>(window);</div>
<div class="ttc" id="agroup__context_html_ga15a5a1ee5b3c2ca6b15ca209a12efd14"><div class="ttname"><a href="group__context.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14">glfwSwapBuffers</a></div><div class="ttdeci">void glfwSwapBuffers(GLFWwindow *window)</div><div class="ttdoc">Swaps the front and back buffers of the specified window.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="quick_process_events"></a>
Processing events</h1>
<p >GLFW needs to communicate regularly with the window system both in order to receive events and to show that it hasn't locked up. Event processing must be done regularly and is normally done each frame before rendering but after buffer swap.</p>
<p >There are two ways to process pending events. <a class="el" href="group__window.html#ga37bd57223967b4211d60ca1a0bf3c832">glfwPollEvents</a> processes only those events that have already been received and then returns immediately. This is the best choice when rendering continually, like most games do.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__window.html#ga37bd57223967b4211d60ca1a0bf3c832">glfwPollEvents</a>();</div>
<div class="ttc" id="agroup__window_html_ga37bd57223967b4211d60ca1a0bf3c832"><div class="ttname"><a href="group__window.html#ga37bd57223967b4211d60ca1a0bf3c832">glfwPollEvents</a></div><div class="ttdeci">void glfwPollEvents(void)</div><div class="ttdoc">Processes all pending events.</div></div>
</div><!-- fragment --><p >If instead you only need to update your rendering once you have received new input, <a class="el" href="group__window.html#ga554e37d781f0a997656c26b2c56c835e">glfwWaitEvents</a> is a better choice. It waits until at least one event has been received, putting the thread to sleep in the meantime, and then processes all received events just like <a class="el" href="group__window.html#ga37bd57223967b4211d60ca1a0bf3c832">glfwPollEvents</a> does. This saves a great deal of CPU cycles and is useful for, for example, many kinds of editing tools.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__window.html#ga554e37d781f0a997656c26b2c56c835e">glfwWaitEvents</a>();</div>
<div class="ttc" id="agroup__window_html_ga554e37d781f0a997656c26b2c56c835e"><div class="ttname"><a href="group__window.html#ga554e37d781f0a997656c26b2c56c835e">glfwWaitEvents</a></div><div class="ttdeci">void glfwWaitEvents(void)</div><div class="ttdoc">Waits until events are pending and processes them.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="quick_example"></a>
Putting it together: A small GLFW application</h1>
<p >Now that you know how to initialize GLFW, create a window and poll for keyboard input, it's possible to create a simple program.</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="glfw3_8h.html">GLFW/glfw3.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> error_callback(<span class="keywordtype">int</span> error, <span class="keyword">const</span> <span class="keywordtype">char</span>* description)</div>
<div class="line">{</div>
<div class="line">    fputs(description, stderr);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> key_callback(<a class="code hl_typedef" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> scancode, <span class="keywordtype">int</span> action, <span class="keywordtype">int</span> mods)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (key == <a class="code hl_define" href="group__keys.html#gaac6596c350b635c245113b81c2123b93">GLFW_KEY_ESCAPE</a> &amp;&amp; action == <a class="code hl_define" href="group__input.html#ga2485743d0b59df3791c45951c4195265">GLFW_PRESS</a>)</div>
<div class="line">        <a class="code hl_function" href="group__window.html#ga49c449dde2a6f87d996f4daaa09d6708">glfwSetWindowShouldClose</a>(window, GL_TRUE);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_typedef" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__error.html#gaa5d796c3cf7c1a7f02f845486333fb5f">glfwSetErrorCallback</a>(error_callback);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code hl_function" href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a>())</div>
<div class="line">        exit(EXIT_FAILURE);</div>
<div class="line"> </div>
<div class="line">    window = <a class="code hl_function" href="group__window.html#ga3555a418df92ad53f917597fe2f64aeb">glfwCreateWindow</a>(640, 480, <span class="stringliteral">&quot;Simple example&quot;</span>, NULL, NULL);</div>
<div class="line">    <span class="keywordflow">if</span> (!window)</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a>();</div>
<div class="line">        exit(EXIT_FAILURE);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__context.html#ga1c04dc242268f827290fe40aa1c91157">glfwMakeContextCurrent</a>(window);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__input.html#ga7e496507126f35ea72f01b2e6ef6d155">glfwSetKeyCallback</a>(window, key_callback);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (!<a class="code hl_function" href="group__window.html#ga24e02fbfefbb81fc45320989f8140ab5">glfwWindowShouldClose</a>(window))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">float</span> ratio;</div>
<div class="line">        <span class="keywordtype">int</span> width, height;</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="group__window.html#ga0e2637a4161afb283f5300c7f94785c9">glfwGetFramebufferSize</a>(window, &amp;width, &amp;height);</div>
<div class="line">        ratio = width / (float) height;</div>
<div class="line"> </div>
<div class="line">        glViewport(0, 0, width, height);</div>
<div class="line">        glClear(GL_COLOR_BUFFER_BIT);</div>
<div class="line"> </div>
<div class="line">        glMatrixMode(GL_PROJECTION);</div>
<div class="line">        glLoadIdentity();</div>
<div class="line">        glOrtho(-ratio, ratio, -1.f, 1.f, 1.f, -1.f);</div>
<div class="line">        glMatrixMode(GL_MODELVIEW);</div>
<div class="line"> </div>
<div class="line">        glLoadIdentity();</div>
<div class="line">        glRotatef((<span class="keywordtype">float</span>) <a class="code hl_function" href="group__time.html#gaa6cf4e7a77158a3b8fd00328b1720a4a">glfwGetTime</a>() * 50.f, 0.f, 0.f, 1.f);</div>
<div class="line"> </div>
<div class="line">        glBegin(GL_TRIANGLES);</div>
<div class="line">        glColor3f(1.f, 0.f, 0.f);</div>
<div class="line">        glVertex3f(-0.6f, -0.4f, 0.f);</div>
<div class="line">        glColor3f(0.f, 1.f, 0.f);</div>
<div class="line">        glVertex3f(0.6f, -0.4f, 0.f);</div>
<div class="line">        glColor3f(0.f, 0.f, 1.f);</div>
<div class="line">        glVertex3f(0.f, 0.6f, 0.f);</div>
<div class="line">        glEnd();</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="group__context.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14">glfwSwapBuffers</a>(window);</div>
<div class="line">        <a class="code hl_function" href="group__window.html#ga37bd57223967b4211d60ca1a0bf3c832">glfwPollEvents</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__window.html#gacdf43e51376051d2c091662e9fe3d7b2">glfwDestroyWindow</a>(window);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a>();</div>
<div class="line">    exit(EXIT_SUCCESS);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="ttc" id="agroup__input_html_ga7e496507126f35ea72f01b2e6ef6d155"><div class="ttname"><a href="group__input.html#ga7e496507126f35ea72f01b2e6ef6d155">glfwSetKeyCallback</a></div><div class="ttdeci">GLFWkeyfun glfwSetKeyCallback(GLFWwindow *window, GLFWkeyfun cbfun)</div><div class="ttdoc">Sets the key callback.</div></div>
</div><!-- fragment --><p >This program creates a 640 by 480 windowed mode window and runs a loop clearing the screen, rendering a triangle and processing events until the user closes the window. It can be found in the source distribution as <code>examples/simple.c</code>, and is by default compiled along with all other examples when you build GLFW.</p>
<p >To learn more about how to compile and link programs that use GLFW, see <a class="el" href="build.html">Building programs that use GLFW</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<address class="footer">
<p>
Last update on Fri Aug 5 2022 for GLFW 3.0.4
</p>
</address>
</body>
</html>
