#pragma once
#include <ImGUI/Shader_Context.h>

// #define STB_IMAGE_WRITE_STATIC
// #define STB_IMAGE_WRITE_IMPLEMENTATION
// #include <helper/stb_image_write.h>
// // import software colortranform
#include <helper/color_transform.h>
using std::string;
// YUV as 2 channel
struct NV122RGB_2C : public I_Render_Task
{
    struct SettingParams : Check_Render_Task_Completeness<SettingParams>
    {
        struct Shader_Params
        {
            // could be set on outside
            Universal_Type_Wrapper<string> texture_path = {"overlay", R"(../media/texture/bmp/9.dib)"};
            Universal_Type_Wrapper<int> mode = {"mode", 0, 0, 3, 0.1};
            Universal_Type_Wrapper<int> back_Width = {"back_Width", 512, 1, 2048, 1};
            Universal_Type_Wrapper<int> back_Height = {"back_Height", 512, 1, 2048, 1};
            // generated by texture
            Universal_Type_Wrapper<int> overlay_Width = {"overlay_Width", 512, 1, 2048, 1};
            Universal_Type_Wrapper<int> overlay_Height = {"overlay_Height", 512, 1, 2048, 1};
            auto GetAllAttr() const { return std::tie(texture_path, mode, back_Width, back_Height, overlay_Width, overlay_Height); }
        };
        Universal_Group_Wrapper<Shader_Params> shader_params = {"Shader params", {}};
        Universal_Type_Wrapper<bool> will_autogen_frame_wh = {"will autogen frame&overlay&back width and height", false};
        Universal_Type_Wrapper<int> frame_width = {"frame width", 1920, 1, 2048, 1};
        Universal_Type_Wrapper<int> frame_height = {"frame height", 1080, 1, 2048, 1};
        Universal_Type_Wrapper<string> vsSrc = {"vert shader source", R"(../src/test_frame/glsl/HANDSOUT/NV122RGB_2C/NV122RGB_2C.vs.glsl)"};
        Universal_Type_Wrapper<string> fsSrc = {"frag shader source", R"(../src/test_frame/glsl/HANDSOUT/NV122RGB_2C/NV122RGB_2C.fs.glsl)"};

        auto GetAllAttr() const { return std::tie(shader_params, will_autogen_frame_wh, frame_width, frame_height, vsSrc, fsSrc); }
    };
    NV122RGB_2C(string const &name, string const &vsSrc, string const &fsSrc, CentralController *cc)
        : I_Render_Task(name, vsSrc, fsSrc, cc) {}

    Cache_Group_Wrapper<SettingParams> params = {"NV122RGB_2C", SettingParams{}};
    // texture obj
    TextureObject tex_Y = {std::numeric_limits<GLuint>::max(), 0};
    TextureObject tex_UV = {std::numeric_limits<GLuint>::max(), 0};

    CachingWrapper<string> vsSrcContent;
    CachingWrapper<string> fsSrcContent;
    bool PrepareExecutingParameters(bool force_reset=false) override
    {
        auto chgParams = !params.SyncCache();
        vsSrcContent.SetSelf(readFile(params->vsSrc.data));
        fsSrcContent.SetSelf(readFile(params->fsSrc.data));
        if(chgParams)
            glfwSetWindowSize(Light::OpenGLContext::CurrentContext()->GetHandle(),params->frame_width.data,params->frame_height.data);
        // params and shader source not changing, just return
        // here checking if program is 0, is to check if program had been initilize
        if (!force_reset&&tex_Y.GetTTexture() != -1&&tex_UV.GetTTexture() != -1 && !chgParams && vsSrcContent.SyncCache() && fsSrcContent.SyncCache())
            return true;
        program = Helper::CreateProgram(ShaderObject(GL_VERTEX_SHADER, vsSrcContent),
                                        ShaderObject(GL_FRAGMENT_SHADER, fsSrcContent));
        auto temp_use = program.temp_use();

        // calc vertex position
        // xucl todo: use operator-> to simplify the longy reference like xxx.data.yyy to xxx->yyy
        float fh = params->frame_height.data, dh = params->shader_params->back_Height.data;
        float fw = params->frame_width.data, dw = params->shader_params->back_Width.data;
        auto vx = dw / fw * 2, vy = dh / fh * 2;
        //std::tie(vao, vbo, veo) = detailed_simpleV_ABE_O<4>(-1, -1 + vx, 1 - vy, 1);
        std::tie(vao, vbo, veo) = detailed_simpleV_ABE_O<4>(-1,1,-1,1);

        Light::BufferLayout layout = {
            Light::BufferElement(Light::ShaderDataType::Float4, "position", false),
            Light::BufferElement(Light::ShaderDataType::Float2, "TextureUV", false)};
        vbo->setLayout(layout);
        vao->addVertexBuffer(vbo);
        vao->setIndexBuffer(veo);
        // xucl error: if all the shaders binding the same GL_TEXTURE1, in the serial calling in cc.Tick()
        // there would be a overwriting behaviour on this GL_TEXTURE1
        // xucl todo: here generate yuv data by hand

        // tex = Helper::CreateTexture(GL_TEXTURE1, params->shader_params->texture_path.data);
        auto rgb_data = Helper::stb_pic_data::create_stb_pic_data(params->shader_params->texture_path.data);
        // nv12 / rgb = 3/2
        auto yuv_data = std::vector<int8_t>(rgb_data->w * rgb_data->h * 3 / 2);
        using T = unsigned char *;
        Rgb2NV12(T(rgb_data->data), 3, rgb_data->w, rgb_data->h, T(yuv_data.data()));
        //stbi_write_bmp("out.bmp",1440,900,1,T(yuv_data.data()));
        stbi_set_flip_vertically_on_load(false);
        writeFile("rawYUV.YUV",std::string(T(yuv_data.data()),T(yuv_data.data())+int(rgb_data->w*rgb_data->h*1.5)));
        auto unis = program.getUniforms();
        auto attrs = program.getAttributes();
        tex_Y = Helper::CreateTextureByData(GL_TEXTURE1, GL_RED, GL_RED, T(yuv_data.data()), rgb_data->w, rgb_data->h );
        tex_UV = Helper::CreateTextureByData(GL_TEXTURE2, GL_RG, GL_RG, T(yuv_data.data()+rgb_data->w*rgb_data->h), rgb_data->w/2, rgb_data->h*0.5 );
       // tex_UV = Helper::CreateTextureByData(GL_TEXTURE2,  GL_LUMINANCE_ALPHA, GL_LUMINANCE_ALPHA, T(yuv_data.data()+rgb_data->w*rgb_data->h), rgb_data->w*0.25, rgb_data->h*0.5 );
        program.setInt("tex_Y", tex_Y.targetTexture - GL_TEXTURE0);
        program.setInt("tex_UV", tex_UV.targetTexture - GL_TEXTURE0);
        SetProgramParam(program,params->shader_params);
        return true;
    }

    void ShowConfig() override
    {
        // constexpr bool s=std::is_integral_v<bool>;
        Draw_element(params, []
                     {
				ImGui::Text("when Shader-params.dst_* and frame width is set up");
				ImGui::Text("the vertex coord will be generated automatically"); });
        if (params->will_autogen_frame_wh.data == true)
        {
            params->frame_height.data = params->shader_params->back_Height.data;
            params->frame_width.data = params->shader_params->back_Width.data;
            params->shader_params->overlay_Height.data = params->shader_params->back_Height.data = tex_Y.height;
            params->shader_params->overlay_Width.data = params->shader_params->back_Width.data = tex_Y.width;
            
        }
    }
    std::string &GetVsSrcFile() override { return params->vsSrc.data; }
    std::string &GetFsSrcFile() override { return params->fsSrc.data; }

private: 
    ~NV122RGB_2C(){

    };
};
